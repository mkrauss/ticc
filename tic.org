* Proposed plan file structure

Rationale: Dependencies should be defined close to the sql files they
describe. When looking at any directory, we should not see multiple
items representing the same thing, such as =create_table.tic= and
=create_table/=.

- supply/
  - supply/plan.tic
  - supply/create_supply_schema/
    - supply/create_supply_schema/plan.tic
    - supply/create_supply_schema/deploy.sql
    - supply/create_supply_schema/revert.sql
    - supply/create_supply_schema/verify.sql
  - supply/create_supplier_table/
    - supply/create_supplier_table/plan.tic
    - supply/create_supplier_table/deploy.sql
    - supply/create_supplier_table/revert.sql
    - supply/create_supplier_table/verify.sql
  - supply/create_part_table/
    - supply/create_part_table/plan.tic
    - supply/create_part_table/deploy.sql
    - supply/create_part_table/revert.sql
    - supply/create_part_table/verify.sql
- logistics/
  - logistics/plan.tic
  - logistics/create_logistics_schema/
    - logistics/create_logistics_schema/plan.tic
    - logistics/create_logistics_schema/deploy.sql
    - logistics/create_logistics_schema/revert.sql
    - logistics/create_logistics_schema/verify.sql
  - logistics/create_shipper_table/
    - logistics/create_shipper_table/plan.tic
    - logistics/create_shipper_table/deploy.sql
    - logistics/create_shipper_table/revert.sql
    - logistics/create_shipper_table/verify.sql
  - logistics/create_route_table/
    - logistics/create_route_table/plan.tic
    - logistics/create_route_table/deploy.sql
    - logistics/create_route_table/revert.sql
    - logistics/create_route_table/verify.sql
* How to get changes from git

This may not be necessary, as I am looking at a way to look at changed
files based on what was deployed versus what is on disk directly,
which would be better...

We can get the current commit HEAD hash with =rev-parse= and store
that when we deploy changes. We can then use =diff= to get the changes
between the last deployed and current versions, and pipe through
dirname and uniq to find the directories containing changes. Then
revert all modified changes and re-deploy!

#+begin_src sh
  git rev-parse HEAD # Get the current commit

  git diff --name-only \
      fc6bb87f9fe3b9ba735f6c37978ea5a96c848d29 \
      0254d85a99e4cac63efa8db8fca21de89c01654e \
      | xargs -L1 dirname \
      | uniq
#+end_src

* TODO Re-engineer revert based on dependencies

Should revert only the requested target and all changes which depend
directly or indirectly on it.

At the same time, this is a good chance to refactor to do reversion by
creating a plan and running it backwards, which will be handy for [[*Add ability to detect changes to changes][Add
ability to detect changes to changes]]

Consider: ability to load the currently deployed Plan from the
database. In such case, we don't need to directly rely on the database
to create specialized plans. Operations only on loaded plans create
specialized plans:

- deploy :: (master plan - deployed plan) -> deploy
- revert :: (deployed plan) -> revert
- rebase :: (deployed plan ð™ master plan) -> revert -> deploy
- update ::
  1. (deployed plan ð™ master plan) -> revert
  2. (master plan - deployed plan) -> deploy
- sync :: 
  1. (deployed plan ð™ master plan) -> revert
  2. (deployed plan - master plan) -> revert
  3. (master plan - deployed plan) -> deploy

* TODO Add ability to detect changes to changes

So we can query the database and see if a change from the plan is
different from what is in the database.

I would like to be able to have a redeploy function that just
redeploys anything that has changed.

Things needed:

- Database function that tells if a change is different from what's
  deployed
- Ability to filter and create a new plan of only those changes and
  the ones that depend on them
- Fix revert to be based on running a plan backwards
